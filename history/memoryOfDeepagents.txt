DeepAgents è®°å¿†ç®¡ç†ç»„ä»¶æ·±åº¦è§£æ

  ğŸ§  AgentMemoryMiddleware è¯¦ç»†åˆ†æ

  æ ¸å¿ƒå®ç°ä½ç½®

  /libs/deepagents-cli/deepagents_cli/agent_memory.py

  1. /agent.md æ–‡ä»¶åŠ è½½æœºåˆ¶

  class AgentMemoryMiddleware(AgentMiddleware):
      def __init__(self, *, backend: BackendProtocol, memory_path: str,
                   system_prompt_template: str | None = None):
          self.backend = backend
          self.memory_path = memory_path  # é»˜è®¤ "/memories/"
          self.system_prompt_template = system_prompt_template or DEFAULT_MEMORY_SNIPPET

      def before_agent(self, state: AgentMemoryState, runtime) -> AgentMemoryState:
          # å»¶è¿ŸåŠ è½½æœºåˆ¶ï¼šåªåœ¨é¦–æ¬¡è¿è¡Œæ—¶åŠ è½½è®°å¿†
          if "agent_memory" not in state or state.get("agent_memory") is None:
              # å›ºå®šè·¯å¾„åŠ è½½ /agent.md
              file_data = self.backend.read(AGENT_MEMORY_FILE_PATH)  # "/agent.md"
              return {"agent_memory": file_data}

  å…³é”®ç‰¹æ€§ï¼š
  - å›ºå®šè·¯å¾„ï¼šç¡¬ç¼–ç  /agent.md ä½œä¸ºé•¿æœŸè®°å¿†æ–‡ä»¶
  - å»¶è¿ŸåŠ è½½ï¼šé¿å…é‡å¤è¯»å–ï¼Œæé«˜æ€§èƒ½
  - çŠ¶æ€æ³¨å…¥ï¼šå°†è®°å¿†å†…å®¹æ³¨å…¥åˆ° state["agent_memory"] ä¸­

  2. è®°å¿†æ¨¡æ¿æ³¨å…¥åˆ°ç³»ç»Ÿæç¤º

  DEFAULT_MEMORY_SNIPPET = """
  <agent_memory>
  {agent_memory}
  </agent_memory>

  ## Memory Management Guidelines

  ### When to Check Memory
  1. **At session start**: Always check /agent.md to understand your role and capabilities
  2. **Before answering**: Review relevant memories to provide consistent responses
  3. **When confused**: Check memories for clarification on your role or preferences
  4. **After feedback**: Update memories based on user corrections or new information

  ### How to Update Memories
  1. **Use write_file**: Create or update memory files when you learn important information
  2. **Be specific**: Include concrete details rather than vague statements
  3. **Organize by topic**: Use separate files for different types of information
  4. **Include context**: Add timestamps and context when updating memories

  ### Memory File Structure
  /memories/
  â”œâ”€â”€ agent.md              # Core identity and role information
  â”œâ”€â”€ project_context.md    # Project-specific information
  â”œâ”€â”€ user_preferences.md   # User preferences and communication style
  â”œâ”€â”€ learning_log.md       # New learnings and insights
  â””â”€â”€ session_notes.md      # Session-specific notes

  ### Using Memory in Practice
  When responding to users, follow this process:
  1. Quickly scan your memories for relevant information
  2. Use that context to inform your response
  3. Update memories if you learn something new about the user or task
  4. Keep memories organized and up-to-date
  """

  æ³¨å…¥æœºåˆ¶ï¼š
  - ç³»ç»Ÿå¯åŠ¨æ—¶è‡ªåŠ¨æ³¨å…¥åˆ°ä»£ç†çš„ç³»ç»Ÿæç¤ºä¸­
  - ä½¿ç”¨ <agent_memory> æ ‡ç­¾åŒ…è£¹è®°å¿†å†…å®¹
  - æä¾›è¯¦ç»†çš„è®°å¿†ç®¡ç†æŒ‡å¯¼åŸåˆ™

  3. è®°å¿†è·¯å¾„é…ç½®æ”¯æŒ

  # é…ç½®ç¤ºä¾‹
  memory_middleware = AgentMemoryMiddleware(
      backend=filesystem_backend,
      memory_path="/custom_memories/",  # è‡ªå®šä¹‰è®°å¿†è·¯å¾„
      system_prompt_template=custom_template  # è‡ªå®šä¹‰æ¨¡æ¿
  )

  é…ç½®é€‰é¡¹ï¼š
  - memory_pathï¼šè‡ªå®šä¹‰è®°å¿†å­˜å‚¨è·¯å¾„å‰ç¼€
  - system_prompt_templateï¼šè‡ªå®šä¹‰è®°å¿†æ³¨å…¥æ¨¡æ¿
  - backendï¼šæŒ‡å®šå­˜å‚¨åç«¯ï¼ˆFilesystemBackend/StoreBackendç­‰ï¼‰

  ---
  ğŸ—„ï¸ å­˜å‚¨åç«¯ç³»ç»Ÿè¯¦ç»†åˆ†æ

  1. StateBackend - ä¸´æ—¶è®°å¿†ï¼ˆä¼šè¯çº§ï¼‰

  # ä½ç½®ï¼š/libs/deepagents/backends/state.py
  class StateBackend(BackendProtocol):
      def __init__(self, runtime: "ToolRuntime"):
          self.runtime = runtime

      def write(self, file_path: str, content: str) -> WriteResult:
          # è·å–å½“å‰çŠ¶æ€ä¸­çš„æ–‡ä»¶æ˜ å°„
          files = self.runtime.state.get("files", {})

          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
          if file_path in files:
              return WriteResult(error=f"File {file_path} already exists, please read it first")

          # åˆ›å»ºæ–°çš„æ–‡ä»¶æ•°æ®
          new_file_data = create_file_data(content)

          # è¿”å›Commandå¯¹è±¡ï¼Œç”¨äºçŠ¶æ€æ›´æ–°
          return WriteResult(path=file_path, files_update={file_path: new_file_data})

      def read(self, file_path: str, offset: int = 0, limit: int | None = None) -> ReadResult:
          files = self.runtime.state.get("files", {})
          if file_path not in files:
              return ReadResult(error=f"File {file_path} not found")

          file_data = files[file_path]
          content = file_data["data"]

          # åº”ç”¨åˆ†é¡µé€»è¾‘
          if limit is not None:
              lines = content.splitlines()
              lines = lines[offset:offset + limit]
              content = "\n".join(lines)
          elif offset > 0:
              lines = content.splitlines()
              content = "\n".join(lines[offset:])

          return ReadResult(
              content=content,
              file_data=file_data,
              lines=lines
          )

  æ ¸å¿ƒç‰¹æ€§ï¼š
  - ä¼šè¯çº§æŒä¹…åŒ–ï¼šæ–‡ä»¶åœ¨å¯¹è¯çº¿ç¨‹å†…æŒä¹…ï¼Œè·¨çº¿ç¨‹ä¸æŒä¹…
  - LangGraph é›†æˆï¼šä½¿ç”¨ LangGraph çš„çŠ¶æ€ç®¡ç†å’Œæ£€æŸ¥ç‚¹æœºåˆ¶
  - Command å¯¹è±¡ï¼šé€šè¿‡ Command å¯¹è±¡æ›´æ–°çŠ¶æ€ï¼Œé¿å…ç›´æ¥å˜å¼‚
  - è‡ªåŠ¨æ£€æŸ¥ç‚¹ï¼šæ¯æ¬¡ä»£ç†æ­¥éª¤åè‡ªåŠ¨æ£€æŸ¥ç‚¹çŠ¶æ€

  2. StoreBackend - é•¿æœŸè®°å¿†ï¼ˆè·¨ä¼šè¯ï¼‰

  # ä½ç½®ï¼š/libs/deepagents/backends/store.py
  class StoreBackend(BackendProtocol):
      def __init__(self, runtime: "ToolRuntime"):
          self.runtime = runtime
          self.default_batch_size = 1000  # é»˜è®¤æ‰¹å¤„ç†å¤§å°

      def _get_namespace(self) -> tuple[str, ...]:
          """è·å–å­˜å‚¨å‘½åç©ºé—´ï¼Œå®ç°å¤šä»£ç†éš”ç¦»"""
          runtime_cfg = self.runtime.config.get("configurable") or {}
          assistant_id = runtime_cfg.get("metadata", {}).get("assistant_id")

          if assistant_id:
              return (assistant_id, "filesystem")  # ä»£ç†çº§åˆ«çš„éš”ç¦»
          return ("filesystem",)  # é»˜è®¤å‘½åç©ºé—´

      def write(self, file_path: str, content: str) -> WriteResult:
          store = self.runtime.store

          # è·å–å‘½åç©ºé—´
          namespace = self._get_namespace()

          # åˆ›å»ºæ–‡ä»¶æ•°æ®
          file_data = create_file_data(content)

          # å­˜å‚¨åˆ° LangGraph Storeï¼ˆè·¨ä¼šè¯æŒä¹…åŒ–ï¼‰
          store.put(namespace, file_path, {"file_data": file_data})

          return WriteResult(
              path=file_path,
              file_data=file_data,
              store_update=(namespace, file_path, {"file_data": file_data})
          )

      def read(self, file_path: str, offset: int = 0, limit: int | None = None) -> ReadResult:
          store = self.runtime.store
          namespace = self._get_namespace()

          # ä»é•¿æœŸå­˜å‚¨ä¸­è¯»å–
          result = store.get(namespace, file_path)
          if result is None:
              return ReadResult(error=f"File {file_path} not found")

          file_data = result.value["file_data"]
          content = file_data["data"]

          # åº”ç”¨åˆ†é¡µé€»è¾‘
          if limit is not None or offset > 0:
              lines = content.splitlines()
              if limit is not None:
                  lines = lines[offset:offset + limit]
              elif offset > 0:
                  lines = lines[offset:]
              content = "\n".join(lines)

          return ReadResult(
              content=content,
              file_data=file_data,
              lines=lines
          )

      def _search_store_paginated(self, store: BaseStore, namespace: tuple[str, ...]) -> list[Item]:
          """åˆ†é¡µæœç´¢å­˜å‚¨å†…å®¹"""
          items = []
          offset = 0

          while True:
              # æ‰¹é‡è·å–å­˜å‚¨é¡¹
              batch_items = store.search(namespace, offset=offset, limit=self.default_batch_size)

              if not batch_items:
                  break

              items.extend(batch_items)
              offset += self.default_batch_size

              # é¿å…æ— é™å¾ªç¯
              if len(batch_items) < self.default_batch_size:
                  break

          return items

  æ ¸å¿ƒç‰¹æ€§ï¼š
  - è·¨ä¼šè¯æŒä¹…åŒ–ï¼šä½¿ç”¨ LangGraph çš„ BaseStore å®ç°è·¨å¯¹è¯æŒä¹…åŒ–
  - å¤šä»£ç†éš”ç¦»ï¼šé€šè¿‡ assistant_id å®ç°å¤šä»£ç†é—´çš„éš”ç¦»
  - å‘½åç©ºé—´ç®¡ç†ï¼šæ”¯æŒå±‚æ¬¡åŒ–å‘½åç©ºé—´ç»„ç»‡
  - åˆ†é¡µæœç´¢ï¼šè‡ªåŠ¨åˆ†é¡µè·å–æ‰€æœ‰æœç´¢ç»“æœ
  - å¤§æ•°æ®æ”¯æŒï¼šå¤„ç†å¤§é‡å­˜å‚¨æ•°æ®çš„æ‰¹å¤„ç†æœºåˆ¶

  3. FilesystemBackend - æ–‡ä»¶ç³»ç»Ÿè®°å¿†

  # ä½ç½®ï¼š/libs/deepagents/backends/filesystem.py
  class FilesystemBackend(BackendProtocol):
      def __init__(self, root_dir: str | Path | None = None,
                   virtual_mode: bool = False,
                   max_file_size_mb: int = 10):
          self.cwd = Path(root_dir).resolve() if root_dir else Path.cwd()
          self.virtual_mode = virtual_mode  # è™šæ‹Ÿæ¨¡å¼
          self.max_file_size_bytes = max_file_size_mb * 1024 * 1024

      def _resolve_path(self, file_path: str) -> Path:
          """å®‰å…¨è·¯å¾„è§£æï¼Œé˜²æ­¢ç›®å½•éå†æ”»å‡»"""
          if not file_path.startswith("/"):
              raise ValueError("File path must be absolute")

          # é˜²æ­¢è·¯å¾„éå†æ”»å‡»
          if ".." in file_path or file_path.startswith("~"):
              raise ValueError(f"Path traversal not allowed: {file_path}")

          # è·¯å¾„è§„èŒƒåŒ–
          normalized = os.path.normpath(file_path).replace("\\", "/")
          if not normalized.startswith("/"):
              normalized = f"/{normalized}"

          # è™šæ‹Ÿæ¨¡å¼è·¯å¾„å¤„ç†
          if self.virtual_mode:
              normalized = normalized.lstrip("/")
              return self.cwd / normalized

          # ç»å¯¹è·¯å¾„å¤„ç†
          return self.cwd / normalized.lstrip("/")

      def write(self, file_path: str, content: str) -> WriteResult:
          full_path = self._resolve_path(file_path)

          # æ–‡ä»¶å¤§å°æ£€æŸ¥
          content_size = len(content.encode('utf-8'))
          if content_size > self.max_file_size_bytes:
              return WriteResult(error=f"File too large: {content_size} bytes")

          # ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
          full_path.parent.mkdir(parents=True, exist_ok=True)

          # å†™å…¥æ–‡ä»¶
          full_path.write_text(content, encoding='utf-8')

          # åˆ›å»ºæ–‡ä»¶æ•°æ®å¯¹è±¡
          file_data = create_file_data(content)

          return WriteResult(
              path=file_path,
              file_data=file_data
          )

      def read(self, file_path: str, offset: int = 0, limit: int | None = None) -> ReadResult:
          full_path = self._resolve_path(file_path)

          if not full_path.exists():
              return ReadResult(error=f"File {file_path} not found")

          # æ–‡ä»¶å¤§å°æ£€æŸ¥
          if full_path.stat().st_size > self.max_file_size_bytes:
              return ReadResult(error=f"File too large to read")

          content = full_path.read_text(encoding='utf-8')

          # åº”ç”¨åˆ†é¡µé€»è¾‘
          lines = content.splitlines()
          if limit is not None:
              lines = lines[offset:offset + limit]
          elif offset > 0:
              lines = lines[offset:]

          formatted_content = "\n".join(lines)

          file_data = create_file_data(formatted_content)

          return ReadResult(
              content=formatted_content,
              file_data=file_data,
              lines=lines
          )

      def grep_raw(self, pattern: str, file_pattern: str = "*") -> list[tuple[str, int, str]]:
          """ä½¿ç”¨ ripgrep è¿›è¡Œé«˜æ€§èƒ½æ–‡æœ¬æœç´¢"""
          try:
              import subprocess

              cmd = ["rg", "--line-number", "--no-heading", pattern, "--glob", file_pattern]
              result = subprocess.run(cmd, cwd=self.cwd, capture_output=True, text=True)

              if result.returncode == 0:
                  matches = []
                  for line in result.stdout.strip().split('\n'):
                      if ':' in line:
                          file_path, line_info = line.split(':', 1)
                          if ':' in line_info:
                              line_num, content = line_info.split(':', 1)
                              matches.append((file_path, int(line_num), content))
                  return matches
              else:
                  return []

          except (subprocess.SubprocessError, FileNotFoundError):
              # å›é€€åˆ° Python å®ç°çš„æœç´¢
              return self._fallback_grep(pattern, file_pattern)

  æ ¸å¿ƒç‰¹æ€§ï¼š
  - ç›´æ¥æ–‡ä»¶ç³»ç»Ÿè®¿é—®ï¼šç›´æ¥è¯»å†™æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ
  - è™šæ‹Ÿæ¨¡å¼ï¼šå°†æ–‡ä»¶æ“ä½œé™åˆ¶åœ¨ç‰¹å®šç›®å½•å†…
  - å®‰å…¨è·¯å¾„è§£æï¼šé˜²æ­¢ç›®å½•éå†æ”»å‡»
  - é«˜æ€§èƒ½æœç´¢ï¼šä½¿ç”¨ ripgrep è¿›è¡Œå¿«é€Ÿæ–‡æœ¬æœç´¢
  - æ–‡ä»¶å¤§å°é™åˆ¶ï¼šé˜²æ­¢å¤„ç†è¿‡å¤§çš„æ–‡ä»¶

  4. CompositeBackend - æ··åˆå­˜å‚¨ç­–ç•¥

  # ä½ç½®ï¼š/libs/deepagents/backends/composite.py
  class CompositeBackend(BackendProtocol):
      def __init__(self, default: BackendProtocol, routes: dict[str, BackendProtocol]):
          self.default = default  # é»˜è®¤åç«¯
          self.routes = routes    # è·¯ç”±è§„åˆ™

          # æŒ‰è·¯å¾„é•¿åº¦æ’åºï¼Œç¡®ä¿æœ€é•¿åŒ¹é…ä¼˜å…ˆ
          self.sorted_routes = sorted(routes.items(), key=lambda x: len(x[0]), reverse=True)

      def _get_backend_for_path(self, file_path: str) -> BackendProtocol:
          """æ ¹æ®æ–‡ä»¶è·¯å¾„é€‰æ‹©åˆé€‚çš„åç«¯"""
          for prefix, backend in self.sorted_routes:
              if file_path.startswith(prefix):
                  return backend
          return self.default

      def write(self, file_path: str, content: str) -> WriteResult:
          backend = self._get_backend_for_path(file_path)
          return backend.write(file_path, content)

      def read(self, file_path: str, offset: int = 0, limit: int | None = None) -> ReadResult:
          backend = self._get_backend_for_path(file_path)
          return backend.read(file_path, offset, limit)

      def ls_info(self, dir_path: str) -> ListResult:
          backend = self._get_backend_for_path(dir_path)
          return backend.ls_info(dir_path)

      def glob_info(self, pattern: str) -> ListResult:
          # glob æ“ä½œéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºæ¨¡å¼å¯èƒ½åŒ¹é…å¤šä¸ªåç«¯
          results = []
          backends_used = set()

          for prefix, backend in self.sorted_routes:
              if pattern.startswith(prefix):
                  if backend not in backends_used:
                      result = backend.glob_info(pattern)
                      results.extend(result.items)
                      backends_used.add(backend)

          # å¤„ç†é»˜è®¤åç«¯çš„glob
          if self.default not in backends_used:
              result = self.default.glob_info(pattern)
              results.extend(result.items)

          return ListResult(items=results)

  æ ¸å¿ƒç‰¹æ€§ï¼š
  - è·¯å¾„è·¯ç”±ï¼šæ ¹æ®è·¯å¾„å‰ç¼€å°†æ“ä½œè·¯ç”±åˆ°ä¸åŒçš„åç«¯
  - æœ€é•¿åŒ¹é…ä¼˜å…ˆï¼šç¡®ä¿æœ€å…·ä½“çš„è·¯ç”±è§„åˆ™ä¼˜å…ˆåŒ¹é…
  - é€æ˜æ“ä½œï¼šä¸ºç”¨æˆ·æä¾›ç»Ÿä¸€çš„æ–‡ä»¶æ“ä½œæ¥å£
  - è·¨åç«¯globï¼šæ”¯æŒè·¨è¶Šå¤šä¸ªåç«¯çš„æ–‡ä»¶æ¨¡å¼åŒ¹é…

  ---
  ğŸ› ï¸ å®é™…ä½¿ç”¨ç¤ºä¾‹

  å®Œæ•´è®°å¿†é…ç½®ç¤ºä¾‹

  from deepagents import create_deep_agent
  from deepagents.backends import (
      FilesystemBackend,
      StoreBackend,
      CompositeBackend
  )
  from deepagents_cli.agent_memory import AgentMemoryMiddleware
  from pathlib import Path

  # 1. åˆ›å»ºä»£ç†ç›®å½•ç»“æ„
  agent_home = Path.home() / ".deepagents" / "code_quality_agent"
  agent_home.mkdir(parents=True, exist_ok=True)

  # åˆ›å»ºè®°å¿†ç›®å½•ç»“æ„
  memory_dirs = ["memories", "projects", "shared", "temp"]
  for dir_name in memory_dirs:
      (agent_home / dir_name).mkdir(exist_ok=True)

  # 2. é…ç½®å„ç§å­˜å‚¨åç«¯
  # é•¿æœŸè®°å¿†åç«¯ï¼ˆæŒä¹…åŒ–ï¼‰
  long_term_backend = FilesystemBackend(
      root_dir=agent_home / "memories",
      virtual_mode=True  # å®‰å…¨æ¨¡å¼
  )

  # é¡¹ç›®è®°å¿†åç«¯
  project_backend = FilesystemBackend(
      root_dir=agent_home / "projects",
      virtual_mode=True
  )

  # å…±äº«è®°å¿†åç«¯ï¼ˆå¤šä»£ç†å…±äº«ï¼‰
  shared_backend = FilesystemBackend(
      root_dir=Path.home() / ".deepagents" / "shared_memories",
      virtual_mode=True
  )

  # ä¸´æ—¶è®°å¿†åç«¯ï¼ˆStateBackend åœ¨ create_deep_agent ä¸­è‡ªåŠ¨é…ç½®ï¼‰

  # 3. åˆ›å»ºå¤åˆåç«¯
  composite_backend = CompositeBackend(
      default=FilesystemBackend(agent_home / "temp"),  # é»˜è®¤ä¸´æ—¶å­˜å‚¨
      routes={
          "/memories/": long_term_backend,     # é•¿æœŸè®°å¿†
          "/projects/": project_backend,       # é¡¹ç›®è®°å¿†
          "/shared/": shared_backend,          # å…±äº«è®°å¿†
          "/agent.md": long_term_backend,      # ä»£ç†é…ç½®æ–‡ä»¶
      }
  )

  # 4. åˆ›å»ºè®°å¿†ç®¡ç†ä¸­é—´ä»¶
  memory_middleware = AgentMemoryMiddleware(
      backend=long_term_backend,
      memory_path="/memories/",
      system_prompt_template="""
      <agent_memory>
      {agent_memory}
      </agent_memory>

      ä½ æ˜¯ä»£ç è´¨é‡ä¸“å®¶ï¼Œä¸“é—¨è´Ÿè´£æ£€æµ‹ã€ä¿®å¤å’ŒéªŒè¯ä»£ç é—®é¢˜ã€‚

      ## è®°å¿†ä½¿ç”¨æŒ‡å—
      1. åœ¨ /memories/ ä¸­å­˜å‚¨ä½ çš„ä¸“ä¸šçŸ¥è¯†
      2. åœ¨ /projects/ ä¸­å­˜å‚¨é¡¹ç›®ç‰¹å®šä¿¡æ¯
      3. ä½¿ç”¨ /shared/ ä¸å…¶ä»–ä»£ç†å…±äº«ä¿¡æ¯
      """
  )

  # 5. åˆ›å»ºä»£ç†
  code_quality_agent = create_deep_agent(
      tools=[static_analyzer, code_formatter, test_runner],
      middleware=[memory_middleware],
      backend=composite_backend
  )

  åˆ›å»ºè®°å¿†æ–‡ä»¶

  # åˆ›å»º /agent.md æ–‡ä»¶
  agent_md_content = """# ä»£ç è´¨é‡æ£€æµ‹ä¸“å®¶

  ## è§’è‰²å®šä¹‰
  ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»£ç è´¨é‡æ£€æµ‹å’Œä¿®å¤ä¸“å®¶ï¼Œå…·æœ‰æ·±åº¦ä»£ç åˆ†æèƒ½åŠ›ã€‚

  ## ä¸“ä¸šé¢†åŸŸ
  - é™æ€ä»£ç åˆ†æ
  - å®‰å…¨æ¼æ´æ£€æµ‹
  - æ€§èƒ½ä¼˜åŒ–
  - ä»£ç è§„èŒƒæ£€æŸ¥
  - è‡ªåŠ¨åŒ–ä¿®å¤

  ## å·¥ä½œåŸåˆ™
  1. **å‡†ç¡®æ€§ä¼˜å…ˆ**ï¼šç¡®ä¿æ£€æµ‹ç»“æœå‡†ç¡®æ— è¯¯
  2. **æ¸è¿›å¼ä¿®å¤**ï¼šä¼˜å…ˆä¿®å¤é«˜ä¼˜å…ˆçº§é—®é¢˜
  3. **æœ€å°å½±å“**ï¼šä¿®å¤æ—¶ä¸å¼•å…¥æ–°é—®é¢˜
  4. **å¯è¿½æº¯æ€§**ï¼šè¯¦ç»†è®°å½•æ¯ä¸ªå†³ç­–è¿‡ç¨‹

  ## è®°å¿†ç»„ç»‡
  - `/memories/analysis_patterns/` - åˆ†ææ¨¡å¼è®°å¿†
  - `/memories/fix_strategies/` - ä¿®å¤ç­–ç•¥è®°å¿†
  - `/memories/quality_standards/` - è´¨é‡æ ‡å‡†è®°å¿†
  - `/projects/current/` - å½“å‰é¡¹ç›®ä¿¡æ¯
  """

  long_term_backend.write("/agent.md", agent_md_content)

  # åˆ›å»ºä¸“ä¸šçŸ¥è¯†è®°å¿†æ–‡ä»¶
  analysis_patterns = """# ä»£ç åˆ†ææ¨¡å¼

  ## Python ä»£ç æ¨¡å¼
  - **å¤æ‚åº¦æ£€æµ‹**ï¼šåœˆå¤æ‚åº¦ > 10 éœ€è¦é‡æ„
  - **å‘½åè§„èŒƒ**ï¼šéµå¾ª PEP 8 æ ‡å‡†
  - **æ–‡æ¡£å­—ç¬¦ä¸²**ï¼šå…¬å…±å‡½æ•°å¿…é¡»æœ‰ docstring

  ## å®‰å…¨æ£€æµ‹æ¨¡å¼
  - **SQLæ³¨å…¥**ï¼šæ£€æŸ¥å­—ç¬¦ä¸²æ‹¼æ¥çš„ SQL æŸ¥è¯¢
  - **XSSæ¼æ´**ï¼šæ£€æŸ¥æœªè½¬ä¹‰çš„ HTML è¾“å‡º
  - **ç¡¬ç¼–ç å¯†é’¥**ï¼šæ£€æŸ¥ä»£ç ä¸­çš„æ˜æ–‡å¯†é’¥

  ## æ€§èƒ½æ£€æµ‹æ¨¡å¼
  - **å¾ªç¯ä¼˜åŒ–**ï¼šæ£€æŸ¥åµŒå¥—å¾ªç¯å’Œä½æ•ˆç®—æ³•
  - **å†…å­˜æ³„æ¼**ï¼šæ£€æŸ¥èµ„æºé‡Šæ”¾æ¨¡å¼
  - **æ•°æ®åº“æŸ¥è¯¢**ï¼šæ£€æŸ¥ N+1 æŸ¥è¯¢é—®é¢˜
  """

  long_term_backend.write("/memories/analysis_patterns.md", analysis_patterns)

  ä¸‰ä»£ç†è®°å¿†å…±äº«é…ç½®

  # 1. å…±äº«è®°å¿†åç«¯
  shared_memory_backend = FilesystemBackend(
      root_dir=Path.home() / ".deepagents" / "shared_workspace",
      virtual_mode=True
  )

  # 2. æ£€æµ‹ä»£ç†é…ç½®
  issue_detector = create_deep_agent(
      tools=[static_analyzer, security_scanner],
      middleware=[
          AgentMemoryMiddleware(
              backend=shared_memory_backend,
              memory_path="/shared/detection_agent/"
          )
      ],
      backend=CompositeBackend(
          default=FilesystemBackend(),
          routes={
              "/shared/": shared_memory_backend,
              "/agent.md": shared_memory_backend
          }
      ),
      system_prompt="""ä½ æ˜¯é—®é¢˜æ£€æµ‹ä¸“å®¶ï¼Œè¯¦ç»†è®°å½•ä½ çš„å‘ç°è¿‡ç¨‹åˆ°å…±äº«è®°å¿†ä¸­ã€‚"""
  )

  # 3. ä¿®å¤ä»£ç†é…ç½®
  fix_generator = create_deep_agent(
      tools=[auto_fixer, patch_tool],
      middleware=[
          AgentMemoryMiddleware(
              backend=shared_memory_backend,
              memory_path="/shared/fix_agent/"
          )
      ],
      backend=CompositeBackend(
          default=FilesystemBackend(),
          routes={
              "/shared/": shared_memory_backend,
              "/agent.md": shared_memory_backend
          }
      ),
      system_prompt="""ä½ æ˜¯ä¿®å¤ä¸“å®¶ï¼Œè¯»å–æ£€æµ‹ä»£ç†çš„å…±äº«è®°å¿†å¹¶è®°å½•ä¿®å¤è¿‡ç¨‹ã€‚"""
  )

  # 4. éªŒè¯ä»£ç†é…ç½®
  validator = create_deep_agent(
      tools=[test_runner, verification_tool],
      middleware=[
          AgentMemoryMiddleware(
              backend=shared_memory_backend,
              memory_path="/shared/validation_agent/"
          )
      ],
      backend=CompositeBackend(
          default=FilesystemBackend(),
          routes={
              "/shared/": shared_memory_backend,
              "/agent.md": shared_memory_backend
          }
      ),
      system_prompt="""ä½ æ˜¯éªŒè¯ä¸“å®¶ï¼Œè®¿é—®æ‰€æœ‰ä»£ç†çš„å…±äº«è®°å¿†è¿›è¡Œå®Œæ•´éªŒè¯ã€‚"""
  )

  ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿æ€»ç»“

  AgentMemoryMiddleware ä¼˜åŠ¿

  - âœ… è‡ªåŠ¨è®°å¿†åŠ è½½ï¼šå¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½ /agent.md
  - âœ… æ¨¡æ¿åŒ–æ³¨å…¥ï¼šçµæ´»çš„è®°å¿†æ¨¡æ¿ç³»ç»Ÿ
  - âœ… è·¯å¾„å¯é…ç½®ï¼šæ”¯æŒè‡ªå®šä¹‰è®°å¿†è·¯å¾„

  å­˜å‚¨åç«¯ç³»ç»Ÿä¼˜åŠ¿

  - âœ… å¤šå±‚æ¬¡å­˜å‚¨ï¼šä¸´æ—¶/é•¿æœŸ/æ–‡ä»¶ç³»ç»Ÿ/å…±äº«å­˜å‚¨
  - âœ… æ™ºèƒ½è·¯ç”±ï¼šè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„å­˜å‚¨åç«¯
  - âœ… å®‰å…¨å¯é ï¼šè·¯å¾„éªŒè¯ã€å¤§å°é™åˆ¶ã€è™šæ‹Ÿæ¨¡å¼
  - âœ… é«˜æ€§èƒ½ï¼šripgrep æœç´¢ã€åˆ†é¡µå¤„ç†ã€æ‰¹æ“ä½œ

  è®°å¿†ç®¡ç†èƒ½åŠ›

  - âœ… è·¨ä¼šè¯æŒä¹…åŒ–ï¼šé€šè¿‡ StoreBackend å®ç°
  - âœ… å¤šä»£ç†éš”ç¦»ï¼šé€šè¿‡å‘½åç©ºé—´å®ç°
  - âœ… å…±äº«è®°å¿†ï¼šé€šè¿‡ CompositeBackend å®ç°
  - âœ… æ™ºèƒ½æœç´¢ï¼šæ”¯æŒè·¨åç«¯çš„ç»Ÿä¸€æœç´¢

  è¿™ä¸ªè®°å¿†ç®¡ç†ç³»ç»Ÿä¸ºæ„å»ºå¤æ‚çš„å¤šä»£ç†åä½œç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„åŸºç¡€è®¾æ–½ï¼